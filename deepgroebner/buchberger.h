/**
 * An environment for computing Groebner bases with Buchberger's algorithm.
 */

#ifndef BUCHBERGER_H
#define BUCHBERGER_H

#include <map>
#include <memory>
#include <optional>
#include <vector>
#include <random>

//#include "ideals.h"
#include "polynomials.h"


struct Numpy1DArray{
  int *ptr;
  int size;
};



/**
 * Stores statistics computed during a call to reduce. For now, just an int counting steps.
 */
struct ReduceStats {
  int steps;
};

/**
 * Return a remainder and stats when g is divided by binomials F.
 *
 * @param g Dividend monomial.
 * @param F Divisor binomials.
 */
std::pair<Monomial, ReduceStats> reduce(const Monomial& g, const std::vector<Binomial>& F);


/**
 * Return a remainder and stats when g is divided by binomials F.
 *
 * @param g Dividend binomial.
 * @param F Divisor binomials.
 */
std::pair<Binomial, ReduceStats> reduce(const Binomial& g, const std::vector<Binomial>& F, bool skip);


/**
 * Stores information about an s-pair. For now, just the indices.
 */
struct SPair {
  int i;
  int j;
};


inline bool operator==(const SPair& p1, const SPair& p2) { return (p1.i == p2.i) && (p1.j == p2.j); }


/**
 * Elimination option for managing the pair set.
 *
 * Strategy can be None (eliminate no pairs), LCM (only eliminate pairs that
 * fail the LCM criterion), or GebauerMoeller (use full Gebauer-Moeller elimination).
 */
enum class EliminationType {GebauerMoeller, LCM, None};

enum class CostType {VertexCover, TotalVariation};

/**
 * Update the polynomials and pairs when f is added to the basis G.
 *
 * @param G Current polynomial generators.
 * @param P Current s-pairs.
 * @param f New polynomial to add to the basis.
 * @param elimination Strategy for pair elimination.
 */
void update(std::vector<Binomial>& G,
	    std::vector<SPair>& P,
	    const Binomial& f,
	    EliminationType elimination);


/**
 * Return a minimal Groebner basis from arbitrary Groebner basis G.
 */
std::vector<Binomial> minimalize(const std::vector<Binomial>& G);


/**
 * Return the reduced Groebner basis from minimal Groebner basis G.
 */
std::vector<Binomial> interreduce(const std::vector<Binomial>& G);


/**
 * Reward option for the environment.
 *
 * Option can be Additions to count each polynomial addition (including one for generating the s-polynomial)
 * or Reductions to count number of s-pair reductions.
 */
// enum class RewardType {Additions, Reductions};


/**
 * Stores statistics computed during a call to buchberger.
 */
struct BuchbergerStats {
  int zero_reductions;
  int nonzero_reductions;
  int polynomial_additions;
  double total_reward;
  double discounted_return;
};


/**
 * Selection option for selecting next pairs from the pair set.
 */
enum class SelectionType {First, Degree, Normal, Sugar, Random};

int select_pair(const std::vector<Binomial>& F, const std::vector<SPair>& P, SelectionType selection);

/**
 * Return the Groebner basis for the ideal generated by F using Buchberger's algorithm.
 *
 * @param F Binomial generators of the ideal.
 * @param selection Strategy for pair selection.
 * @param elimination Strategy for pair elimination.
 * @param sort_input Whether to sort the initial generating set by lead monomial.
 * @param sort_reducers Whether to choose reducers in sorted order by lead monomial.
 * @param gamma Discount rate for rewards.
 * @param seed Optional seed if using Random selection.
 */
std::pair<std::vector<Binomial>, BuchbergerStats> buchberger(const std::vector<Binomial>& F,
                     const std::vector<double>& cost_vector,
                     const Monomial& x0,
							       SelectionType selection = SelectionType::Degree,
							       EliminationType elimination = EliminationType::GebauerMoeller,
							       bool sort_input = false,
							       bool sort_reducers = true,
							       double gamma = 0.99,
							       std::optional<int> seed = std::nullopt,
                     int max_iters = 500);


/**
 * Return the Groebner basis for the ideal generated by F and starting pair set S using Buchberger's algorithm.
 *
 * @param F Generating set of the ideal.
 * @param S Current set of remaining s-pairs.
 * @param selection Strategy for pair selection.
 * @param elimination Strategy for pair elimination.
 * @param sort_reducers Whether to choose reducers in sorted order by lead monomial.
 * @param gamma Discount rate for rewards.
 * @param seed Optional seed if using Random selection.
 */
std::pair<std::vector<Binomial>, BuchbergerStats> buchberger(const std::vector<Binomial>& F,
							       const std::vector<SPair>& S,
                     const std::vector<double>& cost_vector,
                     const Monomial& x0,
							       SelectionType selection = SelectionType::Degree,
							       EliminationType elimination = EliminationType::GebauerMoeller,
							       bool sort_reducers = true,
							       double gamma = 0.99,
							       std::optional<int> seed = std::nullopt,
                     int max_iters=500);


/**
 * An environment for computing a Groebner basis using Buchberger's algorithm.
 */
class BuchbergerEnv {

public:

  BuchbergerEnv();

  /**
   * @param markov_filename The file where the initial Markov basis is stored
   * @param elimination Strategy for pair elimination.
   * @param sort_input Whether to sort the initial generating set by lead monomial.
   * @param sort_reducers Whether to choose reducers in sorted order by lead monomial.
   */
  BuchbergerEnv(std::vector<Numpy1DArray> markov_basis,
		int* x0_arr,
		EliminationType elimination = EliminationType::GebauerMoeller,
		bool sort_input = false,
		bool sort_reducers = true,
		int dimension = 0,
		double* cost_arr = NULL,
    std::string stop = "Ops",
    int max_ops = 500,
    double obj = 0);

  // define destructor/copy/move since std::unique_ptr has no copy constructor
  // ~BuchbergerEnv() = default;
  // BuchbergerEnv(const BuchbergerEnv& other);
  // BuchbergerEnv& operator=(const BuchbergerEnv& other);
  // BuchbergerEnv(BuchbergerEnv&& other) = default;
  // BuchbergerEnv& operator=(BuchbergerEnv&& other) = default;

  void reset(int* x0_arr, double* cost_arr, double obj);

  std::pair<double,bool> step(SPair action);

  void seed(int seed) { }
  int select(SelectionType strategy) const {return select_pair(G, P, strategy);}

  int nvars() const { return dim;}
  // int nvars() const { return ideal_gen->nvars(); }
  void initialize_markov_basis();

  std::vector<double> get_cost() const {return cost_vector;}
  double objective();
  double value(std::string strategy = "degree", double gamma = 0.99, int max_iters = 500) const;

  // void generate_cost_vector();

  std::vector<Binomial> G;
  std::vector<SPair> P;

private:
	
  std::vector<std::vector<int>> markov;
  //std::unique_ptr<IdealGenerator> ideal_gen;
  EliminationType elimination;
  bool sort_input;
  bool sort_reducers;
	int dim;
  std::string stop_condition;
  int op_limit;
  int curr_op;
  double target_obj;

	Monomial x0;
	double curr_cost;

	std::vector<double> cost_vector;
  std::vector<Binomial> G_;  // the reducers

};


/**
 * Return the concatenated exponent vectors of the k lead monomials of f.
 *
 * @param f 
 * @param n Number of variables.
 * @param k Number of lead terms to concatenate.
 */
std::vector<int> lead_monomials_vector(const Binomial& f);


/**
 * A BuchbergerEnv with state the matrix of pairs' lead monomials.
 */
class LeadMonomialsEnv {

public:
  LeadMonomialsEnv() {
    std::vector<Numpy1DArray> markov_basis;
    env = BuchbergerEnv(markov_basis, NULL, EliminationType::GebauerMoeller, false, true, 0, NULL);
    n = 0;
    cols = 0;
  };

  /**
   * @param markov_file Name of file containing Markov basis
   * @param sort_input Whether to sort the initial generating set by lead monomial.
   * @param sort_reducers Whether to choose reducers in sorted order by lead monomial.
   */
  LeadMonomialsEnv(std::vector<Numpy1DArray> &markov_basis,
			 int* x0 = NULL,
		   bool sort_input = false,
		   bool sort_reducers = true,
			 int dimension = 0,
			 double* cost_arr = NULL,
       std::string stop = "Ops",
       int max_ops = 500,
       double obj = 0);

  void reset(int* x0_arr, double* cost_arr, double obj);

  std::pair<double,bool> step(int action);

  void seed(int seed) { env.seed(seed); };

  int select(int strategy) {
    if (strategy == 0)
      return env.select(SelectionType::First);
    else if (strategy == 1)
      return env.select(SelectionType::Degree);
    else if (strategy == 2)
      return env.select(SelectionType::Normal);
    else if (strategy == 3)
      return env.select(SelectionType::Sugar);
    else
      return env.select(SelectionType::Random);}

  std::vector<double> get_cost() { return env.get_cost();}
  double objective() { return env.objective();}
  double value(std::string strategy = "degree", double gamma = 0.99, int max_iters = 500) const { return env.value(strategy, gamma, max_iters); }

  std::vector<int> state;
	std::vector<int> basis;
	std::vector<int> pairs;
  int cols;

private:

  BuchbergerEnv env;
  int n;
  std::vector<std::vector<int>> leads;

};

/*
 * Return an iterator to an element picked uniformly at random.
 */
template<class Iter>
Iter choice(Iter begin, Iter end, std::default_random_engine& rng) {
  std::uniform_int_distribution<> dist(0, std::distance(begin, end) - 1);
  std::advance(begin, dist(rng));
  return begin;
}

#endif
